.TH libistr 3 libistr\-VERSION
.SH NAME
libistr \- Improved String Library
.SH SYNOPSIS
.B #include <libistr.h>
.PP
.B typedef char istring;
.SH DESCRIPTION
The istring library (hereafter referred to as libistr) is an efficient and 
simple dynamic string library for C modeled after the SDS string library
(Although libistr is a separate, unforked codebase). This idea for modeling
strings, rather than define a new structure to contain a string's metadata, 
allocates room in front of a char array to store metadata about the string. 
.PP
The reason for the reimplementation of the concept is to allow for a smaller, 
cleaner codebase with very strict error handling and clear concise naming.
Most design changes have been made to avoid ambiguity, like typedefing 
the 
.B istring
type to 
.B char 
instead of
.BR char\ * ,
which makes the library easier to use and less error prone.
.SH GOTCHA'S
1. ALWAYS assign the return value of an 'istr_' prefixed function that returns
an
.B istring *
because the function may have to call a reallocation method on the istring
which will change where your istring should reference.
.TP
DO:
.RS
istring string = istr_new(NULL);
.sp 0
string = istr_append_cstr(string, "hello");
.sp 0
// string still points towards your string, even if a realloc was called.
.sp 0
printf("%s\n", string);
.RE
.TP
DONT:
.RS
istring string = istr_new(NULL);
.sp 0
istr_append_cstr(string, "hello");
.sp 0
// string may not point to your string anymore at this point.
.sp 0
printf("%s\n", string);
.RE
.SH FEATURES
The advantages here are nearly the same as the SDS string library.
.PP
1. The istring model is ease of interoperability with read-only C
.B <string.h>
functions, as the istring can simply be passed as a parameter as if it
were a normal 
.BR char* .
.PP
2. Memory allocation in libistr is very efficient, following a rule to 
keep an istring's size as a power of 2 that can at least hold the amount
of contents specified. The keeps reallocations to a minimum.
.PP
3. Cache locality. Since all the metadata of a string is always prefixed to the
.BR char\ * ,
memory allocated to an istring is always contiguous in memory.
This keeps memory fragmentation low and speed high when using istrings.
.SH FUNCTIONS
.TP
.BI istring*\ istr_new(const\ istring\ * src )
Initialize a new istring. If
.I src
is NULL, then return an empty istring. Otherwise copy the contents of
.I src
to initialize and return an istring. If allocation fails, return NULL.
.TP
.BI istring*\ istr_new_bytes(const\ char\ * bytes ,\ size_t\  bytes_len )
Initialize a new istring. If
.I bytes
is NULL and
.I bytes_len
is \0, return an empty istring. Otherwise copy 
.I bytes_len
of
.I bytes
to initialize and return an istring. If allocation fails, return NULL.
.TP
.BI istring*\ istr_new_cstr(const\ char\ * cstr )
Initialize a new istring. If
.I cstr
is NULL, then return an empty istring. Otherwise copy the contents of
.I cstr
until the first '\\0' character and return an istring. If allocation fails, return NULL.
.TP
.BI istring*\ istr_grow(istring\ * string ,\ size_t\  len )
If
.I len
is greater than the size of
.IR string 's
buffer, then grow the buffer to the size of
.I len
and return the
.IR string .
If allocation fails, then return NULL.
.TP
.BI istring*\ istr_shrink(istring\ * string ,\ size_t\  len )
If
.I len
is greater than the size of
.IR string 's
buffer, then grow the buffer to the size of
.IR len .
.TP
.BI char*\ istr_free(istring\ * string ,\ bool\  free_buf )
Free all memory used by an istring. If
.I free_buf
is true, then free the string buffer inside the istring and return NULL. 
Otherwise return the buffer. If 
.I string
is NULL, then return NULL.
.TP
.BI int\ istr_eq(const\ istring\ * s1 ,\ const\ istring\ * s2 )
Check for equality between two istrings. 
If equal return \0. If not equal return 1. If either argument is NULL, then return -1.
.TP
.BI char\ istr_index(const\ istring\ * string, size_t\  index )
Index the istring with index-overflow protection. If 
.I string
is NULL, then return '\\0'. If
.I index
is greater than
.I string's
length return '\\0'
.TP
.BI istring*\ istr_slice(istring\ * slice ,\ const\ istring\ * src ,\ size_t\  begin ,\ size_t\  end )
Copy a range of characters from 
.I src
to
.I slice
starting at
.I begin
index and ending at
.I end
index. If
.I slice
or
.I str
are NULL, or
.I begin
>
.IR end ,
then return NULL. If allocation fails, then return NULL.
.TP
.BI istring*\ istr_assign(istring\ * dest ,\ const\ istring\ * src )
Reassign an istring's contents. Overwrite any old contents of
.I dest
with 
.I src
until the first '\\0' character is reached. If
.I dest
or
.I src
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI istring*\ istr_assign_cstr(istring\ * string ,\ const\ char\ * cstr )
Reassign an istring's contents. Overwrite any old contents of
.I string
with 
.I cstr
until the first '\\0' character is reached. If
.I string
or
.I cstr
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI istring*\ istr_assign_bytes(istring\ * string ,\ const\ char\ * bytes ,\ size_t\  bytes_len )
Reassign an istring's contents. Overwrite any old contents of
.I string
with
.I bytes_len
amount of
.I bytes
and sets the length accordingly. If
.I string
or
.I bytes
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI istring*\ istr_trunc(istring\ * string ,\ size_t\  len )
Shorten's 
.I string
to the specified
.I len
of bytes. If
.I len
> the length of
.IR string ,
then the entire string is truncated. If
.I string
is NULL, then return NULL.
.TP
.BI char\ istr_pop(istring\ * string )
Remove the last byte from
.I string
and return it. If
.I string
is NULL, then return '\\0'.
.TP
.BI istring*\ istr_write(istring\ * dest ,\ size_t\  index ,\ const\ istring\ * src )
Overwrite the contents of
.I dest
with the contents of
.I src
at position
.IR index .
If 
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents.
If allocation fails, then return NULL. If
.I dest
or
.I src
are NULL, then return NULL.
.TP
.BI istring*\ istr_write_cstr(istring\ * string ,\ size_t\  index ,\ const\ char\ * cstr )
Overwrite the contents of
.I string
with the contents of
.I cstr
at position
.I index
until the first '\\0' character is reached. If 
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents.
If allocation fails, then return NULL. If
.I string
or
.I cstr
are NULL, then return NULL.
.TP
.BI istring*\ istr_write_bytes(istring\ * string, \ size_t\  index, \ const\ char\ * bytes ,\ size_t\  bytes_len )
Overwrite the contents of
.I string
with
.I bytes_len 
of
.I bytes
at position
.IR index .
If
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents. 
If allocation fails, then return NULL. If
.I string
or
.I cstr
are NULL, then return NULL.
.TP
.BI istring*\ istr_remove_bytes(istring\ * string ,\ size_t\  index ,\ size_t\  len )
Removes up to 
.I len 
bytes from 
.I string
at the
.I index
given. If
.I string
is NULL, then return NULL. If
.I index
>
.IR string->len ,
then return NULL.
.TP
.BI istring*\ istr_append(istring\ * dest ,\ const\ istring\ * src )
Append a copy of
.I src
to
.IR dest .
If allocation fails, then return NULL. If
.IR src\  or\  dest
are NULL, then return NULL.
.TP
.BI istring*\ istr_append_cstr(istring\ * string ,\ const\ char\ * cstr )
Append a copy of
.I cstr
to
.IR string
until the first '\\0' character is reached. 
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.TP
.BI istring*\ istr_append_bytes(istring\ * string ,\ const\ char\ * bytes ,\ size_t\ bytes_len);
Append a copy of
.I bytes_len 
of
.I bytes
to
.IR string .
If allocation fails, then return NULL. If
.IR string\  or\  bytes
are NULL, then return NULL.
.TP
.BI istring*\ istr_insert(istring\ * dest ,\ size_t\  index ,\ const\ istring\ * src )
Insert a copy of
.I src
into
.I dest
at
.IR index .
If allocation fails, then return NULL. If
.IR dest\  or\  src
are NULL, then return NULL.
.TP
.BI istring*\ istr_insert_cstr(istring\ * string ,\ size_t\  index ,\ const\ char\ * cstr )
Insert a copy of
.I cstr
into
.I string
at
.IR index
until the first '\\0' character is reached.
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.TP
.BI istring*\ istr_insert_bytes(istring\ * string ,\ size_t\  index ,\ const\ char\ * bytes ,\ size_t\  bytes_len )
Insert a copy
.I bytes_len 
of
.I bytes
into
.I string
at
.IR index .
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.SH CONFORMING TO
The
I libistr
library is guaranteed to conform with C99 or later
.SH AUTHOR
Written by Todd O. Gaunt
