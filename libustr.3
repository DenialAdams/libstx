.TH libustr 3 libustr\-VERSION
.SH NAME
libustr \- Improved String Library
.SH SYNOPSIS
.B #include <libustr.h>
.PP
.B typedef char ustring;
.SH DESCRIPTION
The ustring library (hereafter referred to as libustr) is an efficient and 
simple dynamic string library for C modeled after the SDS string library
(Although libustr is a separate, unforked codebase). This idea for modeling
strings, rather than define a new structure to contain a string's metadata, 
allocates room in front of a char array to store metadata about the string. 
.PP
The reason for the reimplementation of the concept is to allow for a smaller, 
cleaner codebase with very strict error handling and clear concise naming.
Most design changes have been made to avoid ambiguity, like typedefing 
the 
.B ustring
type to 
.B char 
instead of
.BR char\ * ,
which makes the library easier to use and less error prone.
.SH GOTCHA'S
1. ALWAYS assign the return value of an 'ustr_' prefixed function that returns
an
.B ustring *
because the function may have to call a reallocation method on the ustring
which will change where your ustring should reference.
.TP
DO:
.RS
ustring string = ustr_new(NULL);
.sp 0
string = ustr_append_cstr(string, "hello");
.sp 0
// string still points towards your string, even if a realloc was called.
.sp 0
printf("%s\n", string);
.RE
.TP
DONT:
.RS
ustring string = ustr_new(NULL);
.sp 0
ustr_append_cstr(string, "hello");
.sp 0
// string may not point to your string anymore at this point.
.sp 0
printf("%s\n", string);
.RE
.SH FEATURES
The advantages here are nearly the same as the SDS string library.
.PP
1. The ustring model is ease of interoperability with read-only C
.B <string.h>
functions, as the ustring can simply be passed as a parameter as if it
were a normal 
.BR char* .
.PP
2. Memory allocation in libustr is very efficient, following a rule to 
keep an ustring's size as a power of 2 that can at least hold the amount
of contents specified. The keeps reallocations to a minimum.
.PP
3. Cache locality. Since all the metadata of a string is always prefixed to the
.BR char\ * ,
memory allocated to an ustring is always contiguous in memory.
This keeps memory fragmentation low and speed high when using ustrings.
.SH FUNCTIONS
.TP
.BI ustring*\ ustr_new(const\ ustring\ * src )
Initialize a new ustring. If
.I src
is NULL, then return an empty ustring. Otherwise copy the contents of
.I src
to initialize and return an ustring. If allocation fails, return NULL.
.TP
.BI ustring*\ ustr_new_bytes(const\ char\ * bytes ,\ size_t\  bytes_len )
Initialize a new ustring. If
.I bytes
is NULL and
.I bytes_len
is \0, return an empty ustring. Otherwise copy 
.I bytes_len
of
.I bytes
to initialize and return an ustring. If allocation fails, return NULL.
.TP
.BI ustring*\ ustr_new_cstr(const\ char\ * cstr )
Initialize a new ustring. If
.I cstr
is NULL, then return an empty ustring. Otherwise copy the contents of
.I cstr
until the first '\\0' character and return an ustring. If allocation fails, return NULL.
.TP
.BI ustring*\ ustr_grow(ustring\ * string ,\ size_t\  len )
If
.I len
is greater than the size of
.IR string 's
buffer, then grow the buffer to the size of
.I len
and return the
.IR string .
If allocation fails, then return NULL.
.TP
.BI ustring*\ ustr_shrink(ustring\ * string ,\ size_t\  len )
If
.I len
is greater than the size of
.IR string 's
buffer, then grow the buffer to the size of
.IR len .
.TP
.BI char*\ ustr_free(ustring\ * string ,\ bool\  free_buf )
Free all memory used by an ustring. If
.I free_buf
is true, then free the string buffer inside the ustring and return NULL. 
Otherwise return the buffer. If 
.I string
is NULL, then return NULL.
.TP
.BI int\ ustr_eq(const\ ustring\ * s1 ,\ const\ ustring\ * s2 )
Check for equality between two ustrings. 
If equal return \0. If not equal return 1. If either argument is NULL, then return -1.
.TP
.BI char\ ustr_index(const\ ustring\ * string, size_t\  index )
Index the ustring with index-overflow protection. If 
.I string
is NULL, then return '\\0'. If
.I index
is greater than
.I string's
length return '\\0'
.TP
.BI ustring*\ ustr_slice(ustring\ * slice ,\ const\ ustring\ * src ,\ size_t\  begin ,\ size_t\  end )
Copy a range of characters from 
.I src
to
.I slice
starting at
.I begin
index and ending at
.I end
index. If
.I slice
or
.I str
are NULL, or
.I begin
>
.IR end ,
then return NULL. If allocation fails, then return NULL.
.TP
.BI ustring*\ ustr_assign(ustring\ * dest ,\ const\ ustring\ * src )
Reassign an ustring's contents. Overwrite any old contents of
.I dest
with 
.I src
until the first '\\0' character is reached. If
.I dest
or
.I src
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI ustring*\ ustr_assign_cstr(ustring\ * string ,\ const\ char\ * cstr )
Reassign an ustring's contents. Overwrite any old contents of
.I string
with 
.I cstr
until the first '\\0' character is reached. If
.I string
or
.I cstr
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI ustring*\ ustr_assign_bytes(ustring\ * string ,\ const\ char\ * bytes ,\ size_t\  bytes_len )
Reassign an ustring's contents. Overwrite any old contents of
.I string
with
.I bytes_len
amount of
.I bytes
and sets the length accordingly. If
.I string
or
.I bytes
are NULL, then return NULL. 
If allocation fails return NULL.
.TP
.BI ustring*\ ustr_trunc(ustring\ * string ,\ size_t\  len )
Shorten's 
.I string
to the specified
.I len
of bytes. If
.I len
> the length of
.IR string ,
then the entire string is truncated. If
.I string
is NULL, then return NULL.
.TP
.BI char\ ustr_pop(ustring\ * string )
Remove the last byte from
.I string
and return it. If
.I string
is NULL, then return '\\0'.
.TP
.BI ustring*\ ustr_write(ustring\ * dest ,\ size_t\  index ,\ const\ ustring\ * src )
Overwrite the contents of
.I dest
with the contents of
.I src
at position
.IR index .
If 
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents.
If allocation fails, then return NULL. If
.I dest
or
.I src
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_write_cstr(ustring\ * string ,\ size_t\  index ,\ const\ char\ * cstr )
Overwrite the contents of
.I string
with the contents of
.I cstr
at position
.I index
until the first '\\0' character is reached. If 
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents.
If allocation fails, then return NULL. If
.I string
or
.I cstr
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_write_bytes(ustring\ * string, \ size_t\  index, \ const\ char\ * bytes ,\ size_t\  bytes_len )
Overwrite the contents of
.I string
with
.I bytes_len 
of
.I bytes
at position
.IR index .
If
.I index 
is outside the range of
.IR string ,
then
.I string's
buffer is expanded to fit the new contents. 
If allocation fails, then return NULL. If
.I string
or
.I cstr
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_remove_bytes(ustring\ * string ,\ size_t\  index ,\ size_t\  len )
Removes up to 
.I len 
bytes from 
.I string
at the
.I index
given. If
.I string
is NULL, then return NULL. If
.I index
>
.IR string->len ,
then return NULL.
.TP
.BI ustring*\ ustr_append(ustring\ * dest ,\ const\ ustring\ * src )
Append a copy of
.I src
to
.IR dest .
If allocation fails, then return NULL. If
.IR src\  or\  dest
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_append_cstr(ustring\ * string ,\ const\ char\ * cstr )
Append a copy of
.I cstr
to
.IR string
until the first '\\0' character is reached. 
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_append_bytes(ustring\ * string ,\ const\ char\ * bytes ,\ size_t\ bytes_len);
Append a copy of
.I bytes_len 
of
.I bytes
to
.IR string .
If allocation fails, then return NULL. If
.IR string\  or\  bytes
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_insert(ustring\ * dest ,\ size_t\  index ,\ const\ ustring\ * src )
Insert a copy of
.I src
into
.I dest
at
.IR index .
If allocation fails, then return NULL. If
.IR dest\  or\  src
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_insert_cstr(ustring\ * string ,\ size_t\  index ,\ const\ char\ * cstr )
Insert a copy of
.I cstr
into
.I string
at
.IR index
until the first '\\0' character is reached.
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.TP
.BI ustring*\ ustr_insert_bytes(ustring\ * string ,\ size_t\  index ,\ const\ char\ * bytes ,\ size_t\  bytes_len )
Insert a copy
.I bytes_len 
of
.I bytes
into
.I string
at
.IR index .
If allocation fails, then return NULL. If
.IR string\  or\  cstr
are NULL, then return NULL.
.SH CONFORMING TO
The
I libustr
library is guaranteed to conform with C99 or later
.SH AUTHOR
Written by Todd O. Gaunt
