/**
 * struct oystr - Structure for holding '\0'-terminated byte arrays.
 * @len             The length of used bytes in 'buf'.
 * @size            The allocated size of 'buf'.
 * @buf             The character buffer.
 *
 * All fields in the oystr struct are "public" and available for
 * direct modification and assignment. However, do not expect the 
 * functions supplied with oystr to behave correctly if the fields don't
 * are not consistent.
 *
 * An example of an inconsistent modification that will break many oystr
 * functions is something like changing the 'size' field without changing the
 * actually allocated length of 'buf'.
 */

/**
 * oystr_avail() - Check how much space is available in an oystr.
 * @s1               The oystr to validate.
 *
 * The space leftover is the amount of uninitialized memory after any
 * initialized memory in the oystr buffer.
 *
 * Return: The amount of unused space in an oystr buffer.
 */

/**
 * oystr_ensure_size() - Ensure that an oystr can hold at least 'size' bytes.
 * @s1                     The oystr to modify.
 * @size                   The target size.
 *
 * Please note that this function allocates enough for 'size' + 1, and grows
 * the buffer as powers of two.
 *
 * Return: OYSTR_OK upon successful resize.
 *	   OYSTR_ERR if the reallocation failed, or if the new size would've
 *	   overflowed the maximum value of a size_t.
 */

/**
 * oystr_init() - Initialize an oystr.
 * @s1              The oystr to initialize.
 *
 * Make sure no memory is allocated to any oystr fields as it will be
 * lost upon calling this function unless the caller holds references to those
 * fields.
 */

/**
 * oystr_init_buf() - Initialize and allocate an oystr.
 * @s1                  The oystr to initialize.
 * @size                The target inital size for 's1->buf'.
 *
 * All fields except for 's1->buf' are set to 0. The memory allocated for the
 * oystr buffer will be at least 'size' and is unintialized.
 * Return: OYSTR_OK if the function is successful.
 *	   OYSTR_ERR if the reallocation failed, or if the new size would've
 *	   overflowed the maximum value of a size_t.
 */

/**
 * oystr_deinit() - Deinitialize an oystr.
 * @s1                The oystr to deinitialize.
 * 
 * The oystr is deinitialized by freeing all fields that could reference
 * allocated memory and then setting them to NULL. All other fields are simply
 * set to 0.
 *
 * 's1->buf' must either be NULL or malloc'd memory, otherwise behavior is
 * undefined.
 */

/**
 * oystr_valid() - Validate the fields of an oystr.
 * @s1               The oystr to validate.
 *
 * Validation is useful if dealing with an oystr where the caller may not be 
 * sure if the oystr was modified properly or not.
 *
 * Return: true if 's1->size' > 0,
 *                 's1->len' < 's1->size',
 *                 's1->buf' != NULL.
 *         false if otherwise.
 */

/**
 * oystr_set_len - Change the length of an oystr and '\0'-terminate it.
 * @s1               The oystr to modify.
 * @len              The length that 's1->len' will be set to.
 *
 * Return: OYSTR_ERR If 'len' > 's1->size' - 1.
 *         OYSTR_OK otherwise.
 */

/**
 * oystr_eq() - Compare two oystrs for equality.
 * @s1            The first oystr to compare.
 * @s2            The second oystr to compare.
 *
 * Returns false if the contents of @s1.buf are not the same as @s1.buf,
 * otherwise returns true.
 */

/**
 * Swap the contents of two oystrs.
 *
 * This function is equivalent to just assigning two structs to one another
 * while using a temporary struct as a buffer.
 */

/**
 * Truncate @s1 by @len bytes.
 *
 * Returns the last character truncated. If @len > @s1.len, @s1.len is set to 0
 * and '\0' is returned.
 */

/**
 * Assign the contents of @bytes to @s1.
 *
 * If @s1.buf doesn't not contain enough room to hold @bytes, @s1.buf will be
 * reallocated. Returns ISTR_ERR upon any reallocation error, otherwise returns
 * ISTR_OK.
 */

/**
 * Assign the contents of @s2 to @s1.
 * 
 * A convenience wrapper around oystr_assign.
 */

/**
 * Write @bytes directly over @s1 starting at index @pos.
 *
 * This function overwrites bytes directly, and doesn't make any calls to
 * memmove. If the bytes being written would extend beyond @s1.buf, then @s1.buf
 * is reallocated.
 *
 * Returns ISTR_ERR upon allocation failure, otherwise ISTR_OK.
 */

/**
 * Write @s2 directly over @s1 starting at index @pos.
 *
 * A convenience wrapper around oystr_write.
 */
