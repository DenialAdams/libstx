.TH LIBSTX 7 libstx
.SH NAME
libstx - Dynamic string handling library.
.SH SYNOPSIS

.B #include <libstx.h>

stx mystx;

.B #include <libstx.hpp>

libstx::stx mystx;
.SH Description
.B libstx
is a C library for enhanced string handling. The goals of this library are to be 
small, fast, and to handle heap-allocated strings just as well as stack
allocated strings.
.P
.B libstx
approaches C string handling in a rather traditional way, using a C structure to
contains the memory for the string, and two additional fields for
keeping track of thow many bytes were allocated, and one more to keep track of
how many of those bytes are actually being used.
.P
However,
.B libstx
does not automatically grow this
memory, and does not perform validation checks every single function
call. Instead this is left up to the user of the library, to call inbetween
string handling operations that might either need to grow the memory to a large 
size or validate the string since the caller should know where it is most
optimal to perform these operations.
.SS libstx format
provided with libstx are two structures, stx and spx. A struct stx is for
referencing dynamically resizable and mutable character array, while a struct
spx is used for constantly referencing a another stx or spx. All member fields
are defined as part of the API.
.P
.in +4n
.nf
struct stx {
	char *mem;   // Character memory.
	size_t len;  // Length of used bytes in \fImem\fP.
	size_t size; // Size of the \fImem\fP field.
};

struct spx {
	const char *mem;   // Character memory.
	const size_t len;  // Length of used bytes in \fImem\fP.
};

typedef struct stx stx;
typedef struct spx spx;
.fi
.in
.P
A valid struct stx is defined as one where
.I mem
!= NULL,
.I len
<
.IR size ,and
.I size
!= 0.
An example of an inconsistent modification that will break many libstx
functions is something like changing the \fIsize\fP field without changing 
the actually allocated size of \fImem\fP.
.P
.B libstx
functions that write to the struct stx in any way will always
update the
.I len
field of the struct stx. This is implied functionality of the library that will
always occur unless a function explicity states it does not conform to this
behavior.
.SH RATIONALE
Many string library unnecessarily force the user to allocate memory they don't
plan on using (GLib GString), don't properly check for unsigned integer
overflows (bstrlib), or repeatedly validate function input over and over
(bstrlib) causing needless overhead.
.P
.B libstx
functions are designed to be able to be composed together, allowing
functions to be composed in an elegant way that doesn't require naming new
functions that simply call one or more other functions.
.P
.B libstx
functions do no input validation, but there is a provided validation function
provided. This allows the caller to validate a struct stx when it is most 
appropriate, rather than penalize the caller by unnecessarily checking in every 
single call into the library. Be warned that the user MUST validate any
function that changes the allocated memory of struct stx, as that relies on
malloc() which should always be checked.
.SH COMPATIBILITY
.B libstx
is compatible with pure C99 onwards, and provides a wrapper for C++,
included with <libstx.hpp>, that provides conveience features such as operator
overloading, and a single namespace of 'libstx' to contain all of the libraries
functions instead of a prefix of 'stx' on each function name (Although pure C
versions of all functions are still available within that namespace).
.SH AUTHOR
Written by Todd O. Gaunt.
.SH SEE ALSO
.BR stxapp (3),
.BR stxcpy (3),
.BR stxavail (3),
.BR stxdel (3),
.BR stxensure_size (3),
.BR stxeq (3),
.BR stxfind (3),
.BR stxnew (3),
.BR stxins (3),
.BR stxslice (3),
.BR stxstrip (3),
.BR stxtrunc (3),
.BR stxuni8f32 (3),
.BR stxval (3),
